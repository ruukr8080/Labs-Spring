## JWT (JSON Web Token)
> - JSON 포맷을 기반으로 하는 웹 토큰이다.
> - 서버와 클라이언트 간에 정보를 안전하게 주고받기 위해 사용하는 표준.
> - 토큰 자체에 필요한 모든 정보가 들어있어서 Self-Contained라고 불리기도 함.


### JWT의 구조

> JWT는 세 가지 파트로 구성되어 있고, 각 파트는 마침표(.)로 구분된다. 
> `Header.Payload.Signature` 
```json
//header
{"alg": "HS256", "typ": "JWT"}
//payload
{ "iss": "example.com",
  "exp": 1672531200,
  "user_id": "12345",
  "roles": ["admin", "user"]
}
//signature

```

1. **Header**  
토큰의 타입(typ)과 서명에 사용된 암호화 알고리즘(alg)이 담겨 있음. 보통은 `HS256`이나 `RS256`같은 알고리즘을 사용함. 이 정보는 JSON 형태로 되어 있고, `Base64Url`로 인코딩됨.  
   
    ```json
    {
    "alg": "HS256",
    "typ": "JWT"
    }
    ```
    
2. **Payload**  
토큰에 담을 정보, 즉 **클레임(Claim)**이 들어 있는 부분임. 클레임도 키-값 쌍으로 구성되어 있음.

    ```json
    {
    "iss": "example.com", // 발급자
    "exp": 1672531200, // 만료시간
    "user_id": "12345", // 사용자 id
    "roles": ["admin", "user"] // 사용자 권한
    }
    ```

   - *Registered Claims* : 미리 등록된 클레임.  
    iss(발급자), exp(만료 시간), sub(주제) 같은 것들이 있음.
        > 필수는 아니지만 사용하는 것이 권장됨.

   - *Public Claims* : 공개 클레임.  
   사용자 정의 클레임으로, 공개용 정보를 위해 사용됨. 
        > 충돌 방지를 위해 URI 포맷을 사용하기도 함.

   - *Private Claims* : 비공개 클레임.  
    서버와 클라이언트 간에만 공유되는 정보를 담음.

    🚨`Payload`는 Base64Url로 인코딩만 되어 있기 때문에, 누구나 쉽게 디코딩해서 내용을 볼 수 있다. 그래서 민감한 정보(비밀번호, 개인 정보 등)는 절대 여기에 넣으면 안 됨.

3. **Signature==서명**
> 토큰의 위변조 여부를 확인하는 용도. Header와 Payload를 특정 알고리즘으로 서명한 값


헤더와 페이로드를 Base64Url로 인코딩한 값을 합친 후, 서버의 **Secret Key**와 헤더에 명시된 알고리즘(`SHA356`,`RSA`,`ES256`, 등...)을 사용해 암호화해서 문자열로 만듬.   
공격자가 헤더와 페이로드를 알아낸다해도 서버 비밀키는 알기 어려움.

### JWT의 작동 방식
1. 클라이언트가 로그인 요청을 한다. (아이디, 비밀번호 전송)

2. 서버에서 JWT 발급. 서버는 로그인 정보를 확인한 후, 헤더, 페이로드, 그리고 비밀 키를 이용해 시그니처를 만들고, 이 세 부분을 합쳐 JWT를 생성함.

3. 클라이언트에게 JWT 전달. 서버는 생성된 JWT를 HTTP 응답을 통해 클라이언트에게 보냄.

3. 클라이언트가 JWT를 저장. 클라이언트는 JWT를 웹 스토리지(로컬 스토리지, 세션 스토리지)나 쿠키 등에 저장함.

4. 클라이언트가 API 요청 시 JWT 첨부. 이후 클라이언트는 보호된 리소스에 접근할 때마다 HTTP 헤더에 JWT를 첨부해서 서버로 보냄.

5. 서버에서 JWT 유효성 검증. 서버는 클라이언트로부터 받은 JWT의 시그니처를 자체적으로 재계산하고, 받은 토큰의 시그니처와 비교해서 토큰의 위변조 여부를 확인함. 만약 일치하면 페이로드의 정보(예: 사용자 ID, 권한)를 확인하고 요청에 대한 응답을 보냄.

---



## JWT 기반 vs Session 기반

#### 세션 기반 인증: `STATEFUL`

  - 최초 인증(클라 로그인) : id/비번 입력해서 (POST/login) 서버로 보냄.  
    ```
    서버 :
    1. 아이디/비번 확인 → 서버에서 DB에 세션 테이블 만들고 세션ID 생성
    2. 세션ID를 사용자 정보와 매핑해서 DB(혹은 Redis 등)에 저장
    3. 세션ID를 쿠키로 응답에 실어 클라에 반환.
    ```
  - 인증 이후 : 매 요청마다 쿠키에 세션ID 담아서 서버에 (POST/GET 등) 보냄 
    ```
    서버 : 
    1. 요청 헤더에서 세션ID 꺼내서 DB(세션 저장소)에서 사용자 정보 조회
    2. 조회된 사용자 정보로 인가(권한 체크 등) 처리
    3. 응답 반환
    ```  
  - 세션 만료/로그아웃 : 로그아웃 요청/만료 시, 서버에 세션ID 삭제 요청 날림.
    ```
    서버: 
    세션 정보 소멸, 클라의 세션ID 무효화
    ```
    
#### JWT 기반 인증:  `STATELESS`  
  - 최초 인증(클라 로그인) : id/비번 입력해서 (POST/login) 서버로 보냄.  
    ``` 
    서버:
    1. 아이디/비번 확인 → 서버에서 JWT 토큰 생성(사용자 정보, 만료 등 payload에 포함)
    2. 비밀키로 서명해서 발급
    3. JWT 토큰을 클라에 응답으로 줌 (보통 Authorization 헤더, 또는 localStorage)
    ```
  - 인증 이후 : 매 요청마다 JWT 토큰을 Authorization 헤더에 담아 서버에 보냄
    ```
    서버:
    1. JWT 토큰 꺼내서, 비밀키로 위변조 여부 검증
    2. 토큰 payload에 담긴 사용자 정보로 인가(권한 체크 등) 처리
    3. 응답 반환
    ```
  - 토큰 만료/로그아웃-`STATELESS`
    ```
    서버 : 
    서버는 애초에 토큰(상태)를 따로 저장 안 하기 때문에 클라에서 그냥 토큰 삭제 됨.
    토큰 만료시엔 refresh토큰으로 갱신(재발급)함
    ```
       
---

### `STATELESS` : 

> 서버가 별도의 세션 저장소를 관리할 필요가 없어 서버의 부담이 줄어듦.
그러나 페이로드에 많은 정보를 담을수록 토큰의 크기가 커져 네트워크 부하가 증가할 수 있음.

여러 서버에 걸쳐 서비스를 확장할 때(마이크로서비스 등), 각 서버가 중앙 세션 저장소에 의존하지 않고 독립적으로 토큰을 검증할 수 있기 때문에 확장성이 용이하다고 말할 수 있다.

모바일 환경 적합하다고 함.  
모바일 앱에서는 쿠키를 사용하기 어려울 수 있는데, JWT는 헤더에 담아 보내는 방식이라 유연하다고 함

주의 사항으로는 토큰이 탈취되면 만료될 때까지 탈취한 사람이 사용자의 권한으로 요청을 보낼 수 있으며 세션처럼 서버에서 강제로 로그아웃시키거나 만료시킬 방법이 마땅치 않기 때문에 매우 치명적임. 
> 리프레시 토큰, 블랙리스트 등 추가적인 보안 대책을 마련해야 한다.  

또한, 페이로드는 인코딩만 되어 있어 중요한 정보를 담을 수 없음.



