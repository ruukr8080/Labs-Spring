# CSRF

**CSRF(Cross-Site Request Forgery)**

CSRF는 사용자가 의도치 않은 요청을 보내는 공격 방식이다. 사용자가 로그인된 상태에서 공격자가 만든 악성 스크립트가 담긴 페이지에 접속하면, 사용자의 권한으로 특정 행동을 수행하게 만든다. 주로 XSS 공격과 혼동되곤 하는데, XSS는 스크립트 코드를 주입해서 실행시키는 공격이고, CSRF는 사용자의 권한을 이용해서 요청을 보내는 공격이라는 차이가 있다.

이 공격은 사용자가 로그인되어 있는 웹사이트의 취약점을 노리는 게 핵심이다. 사용자가 정상적으로 웹사이트에 로그인하고 세션이 유지되고 있을 때, 공격자가 악성 링크나 이미지를 심어놓은 다른 사이트로 사용자를 유도하는 방식이다.

> 예를 들어, 사용자가 은행 웹사이트에 로그인한 상태에서 악성 사이트에 접속했다고 한다면. 악성 사이트에 심어놓은 스크립트가 '계좌 이체' 요청을 보내도록 설정되어 있고, 사용자는 자신도 모르는 사이에 공격자에게 돈을 보내게 될 수도 있다.

## CSRF 공격

### CSRF 공격 1. 이미지 태그 사용

> CSRF 공격은 이미지 태그를 이용해 특정 URL로 요청을 보내는 방법이 많이 쓰인다.

```html
<img src="[https://bank.com/transfer?to=hacker&amount=1000000](https://bank.com/transfer?to=hacker&amount=1000000)" />
```
사용자가 이 이미지가 포함된 페이지를 로드하면, 브라우저는 

'https://www.google.com/search?q=https://bank.com/transfer%3Fto%3Dhacker%26amount%3D1000000` 라는 URL로 이미지를 요청하게 된다.
 이때 사용자가 bank.com에 로그인된 상태라면, 요청과 함께 세션 쿠키가 전송되어 공격이 성공하게 됨.

### CSRF 공격 2. Form 태그 사용

> 숨겨진 `<form>` 태그를 이용해 사용자가 알지 못하게 POST 요청을 보내는 방식.

```HTML
<form id="csrf-form" action="[https://bank.com/transfer](https://bank.com/transfer)" method="POST">
  <input type="hidden" name="to" value="hacker" />
  <input type="hidden" name="amount" value="1000000" />
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

사용자가 이 코드가 있는 페이지에 접속하면, 자바스크립트가 자동으로 form을 전송해서 계좌 이체 요청을 보내버림.

## CSRF 방어: 요청 검증
CSRF를 막는 가장 좋은 방법은 '요청이 의도된 것인지' 서버에서 검증하는 거다. 브라우저는 요청을 보낼 때 `SameSite` 옵션을 보냄으로써 CSRF를 예방할 수 있다. 그리고 서버는 'Referer' 헤더나 CSRF 토큰 같은 걸 활용해서 요청의 유효성을 검사할 수 있다.

### CSRF 방어 1. CSRF 토큰 사용

> CSRF 토큰 방식이 가장 강력하고 보편적인 방어책이다.
로그인 시 사용자의 세션에 **Random Token**를 생성하고, 모든 중요한 요청(예: 계좌 이체, 비밀번호 변경)에 이 토큰을 포함시켜서 서버에 보내는 방식이다.

```md
1. 사용자가 로그인하면 서버가 CSRF 토큰을 생성하고 세션에 저장한다.

2. 이후 중요한 작업을 위한 폼(form)을 만들 때, 서버는 숨겨진 입력 필드(<input type="hidden">)에 이 토큰을 넣어준다.

3. 사용자가 폼을 제출하면, 서버는 요청에 포함된 토큰과 세션에 저장된 토큰이 일치하는지 확인한다.
```

공격자가 CSRF 공격을 하려면 이 토큰 값을 알아내야 하는데, CSRF 공격 페이지에서는 다른 사이트의 세션 토큰에 접근할 수 없기 때문에 공격이 실패하게 됨.


### CSRF 방어 2. Referer 검증
> HTTP 요청 헤더에 있는 Referer 값으로 요청이 어디서 왔는지를 검사하는 방식이다.


```md 
1. 서버는 요청이 들어올 때 Referer 헤더를 확인한다.

2. Referer 헤더에 담긴 URL이 우리 사이트의 URL이 맞는지 검증한다.

3. 만약 Referer가 우리 사이트가 아니라면, 그건 다른 외부 사이트에서 온 요청이라고 보고 차단해버린다. 


```
요청이 같은 도메인에서 왔을 때만 허용하도록 서버를 설정하면 된다. 다만, 이 방식은 Referer 헤더를 조작하거나, 사용자의 브라우저 설정에 따라 헤더가 전송되지 않을 수도 있어서 완벽한 방어책은 아님.


### CSRF 방어 3. SameSite 쿠키 옵션
> `동일 출처 정책 (Same-Origin Policy) - SameSite`
> SameSite는 쿠키에 설정할 수 있는 옵션으로, CSRF 방어에 효과적이다.

SameSite 옵션을 Strict나 Lax로 설정하면, 크로스 사이트 요청 시 쿠키가 전송되지 않도록 할 수 있다.

Strict: 동일 출처(Same-Origin) 요청에만 쿠키를 보낸다.

Lax: 동일 출처 요청에는 쿠키를 보내고, `<a href="...">` 같은 일부 GET 요청에는 보내주지만, `<img src="...">` 나 `<form>`의 POST 요청 같은 크로스 사이트 요청에는 보내지 않는다.

SameSite=Lax가 가장 많이 사용되는 방식인데, 사용성을 해치지 않으면서도 CSRF 공격을 효과적으로 막을 수 있기 때문이다.

--- 
### 결론 

CSRF 공격은 주로 로그인된 사용자의 권한을 훔치는 것이 목표다. 
따라서 로그인이 필요한 페이지나 민감한 정보를 다루는 기능에 `CSRF 토큰`을 반드시 적용해야 한다.

```md
`OWASP`에서 제공하는 CSRF 공격 방지를 위한 치트시트.

  1. CSRF 토큰을 사용해 요청의 유효성을 검증하라.
  2. SameSite 쿠키 속성을 사용해 쿠키 전송 범위를 제한하라.
  3. Referer 헤더를 검증하여 요청의 출처를 확인하라.
  4. GET 요청에는 상태 변경(State Change)을 유발하는 기능을 넣지 마라.
  5. 사용자에게 민감한 작업(예: 비밀번호 변경) 전에는 재인증을 요구하라.
```
